==============
Reorder Buffer
==============

Буфер змінного порядку або буфер відновлення послідовності дозволяє
відслідковувати виконання інструкцій зберігаючи чітку послідовність.
Після модуля перейменовування в нас з'являється запитання як відслідковувати
виконані іструкції. Так як після перейменування і виконнання іструкції
відбувається процедура здійснення "commit". Якщо це зробити раніше
ми отримаємо не коректне значення так як даний регістра може бути
вокористаний для інших іструкцій.

.. image:: ../img/rob.png
   :width: 800
   :align: center

Модуль побудований на основі кільцевого буфера.
Показник "tail" вказує на комірку для запису нової інструкції.
Показник "head" вказує на іструкції які готуються для commit.

В кожній банці є комірки в якіх зберігаються інструкції.
Комірка банки має:

- Адресу для пакета інструкцій;
- Біт валідності;
- Біт занятості;
- Попередній регістр;
- Маска гілки.

В модулі є чотири банки в якиї зберігається іструкції, які будуть виконуватися,
виконуються на даний момент або вже виконалися.
На це вказують біти валідності в занятості.
Після виконнаня іструкції сигнал повертається в даний модуль і скидає біт
занятості виконаної іструкції.

Запис відбувається всього пакета.
Кожна інструкція відповідно до банки.
Адреса зберігається окремо і представляє весь рядок.
В даному буфері зберігаєть вирівнення іструкцій тому номер банки вказує
на зміщення інструкції в пакеті. Тому ми можемо відновити адресу іструкці
і цим заощадити ресурси які виділяють для адреси. 


Commit Stage
~~~~~~~~~~~~

Розлянемо самий найстарший пакет на який вказує показник head.
Якщо всі іструкції в даному пакеті виконалися то ми можемо чітко сказати
що старе перейменоване значення оригільного регістра вже не потрібне.
Всі наступні іструкції залежатать від нового вже виконаного перейменованого
регістра.
Відбувається комміт старого регістра і зміщується "head".
Отже здійснення коміта відбувається в тій послідовність як і перейменовування.

Jump miss
~~~~~~~~~

При промаху передбачення гілки в модулі пострібно прибрати всі іструкції
які знаходяться після іструкції переходу гілки.
Це реалізовано за допомогою маски гілки.

